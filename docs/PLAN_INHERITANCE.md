# План разработки: Наследование классов Product

## Общая информация

**Цель:** Расширить функционал магазина путем создания базового класса и классов-наследников для специализированных категорий товаров.

**Тематика:** Наследование, полиморфизм, проверка типов (`isinstance`, `issubclass`, `type()`)

**Целевой файл для проверки:** `16.1_main.py` - весь код в этом файле должен работать без ошибок после выполнения плана.

**Критерии приемки:**
- ✅ Созданы классы `Smartphone` и `LawnGrass` как наследники `Product`
- ✅ Метод `__add__` позволяет складывать только товары одинаковых классов
- ✅ Метод `add_product` защищен от добавления не-продуктов
- ✅ Все существующие тесты проходят без ошибок
- ✅ Написаны новые тесты для всей функциональности
- ✅ **Код в `16.1_main.py` выполняется без ошибок** (после добавления импортов)

---

## Задание 1: Создание классов-наследников

### 1.1. Анализ требований

**Задача:** Создать два класса-наследника от `Product`:
- `Smartphone` - для смартфонов
- `LawnGrass` - для травы газонной

**Декомпозиция:**

#### 1.1.1. Класс Smartphone
- **Родительский класс:** `Product`
- **Дополнительные атрибуты:**
  - `efficiency` (float) - производительность (например: 95.5, 98.2, 90.3)
  - `model` (str) - модель (например: "S23 Ultra", "15", "Note 11")
  - `memory` (int) - объем встроенной памяти в ГБ (например: 256, 512, 1024)
  - `color` (str) - цвет (например: "Серый", "Gray space", "Синий")
- **Наследуемые атрибуты:** `name`, `description`, `price`, `quantity`
- **Наследуемые методы:** `__init__`, `__str__`, `__add__`, `price` (property), `new_product` (classmethod)

#### 1.1.2. Класс LawnGrass
- **Родительский класс:** `Product`
- **Дополнительные атрибуты:**
  - `country` (str) - страна-производитель
  - `germination_period` (str) - срок прорастания
  - `color` (str) - цвет
- **Наследуемые атрибуты:** `name`, `description`, `price`, `quantity`
- **Наследуемые методы:** `__init__`, `__str__`, `__add__`, `price` (property), `new_product` (classmethod)

### 1.2. План реализации

#### Шаг 1.1: Создание класса Smartphone
1. Открыть файл `src/product.py`
2. После класса `Product` добавить класс `Smartphone`
3. Наследовать от `Product`: `class Smartphone(Product):`
4. Реализовать `__init__`:
   - Принять все параметры родительского класса (`name: str`, `description: str`, `price: float`, `quantity: int`)
   - Принять дополнительные параметры (`efficiency: float`, `model: str`, `memory: int`, `color: str`)
   - Вызвать `super().__init__(name, description, price, quantity)` для инициализации родительских атрибутов
   - Установить дополнительные атрибуты: `self.efficiency = efficiency`, `self.model = model`, `self.memory = memory`, `self.color = color`
5. Добавить docstring с описанием класса и атрибутов
6. Добавить примеры использования в docstring (см. `16.1_main.py` для примеров)

#### Шаг 1.2: Создание класса LawnGrass
1. В том же файле `src/product.py` после класса `Smartphone` добавить класс `LawnGrass`
2. Наследовать от `Product`: `class LawnGrass(Product):`
3. Реализовать `__init__`:
   - Принять все параметры родительского класса (`name: str`, `description: str`, `price: float`, `quantity: int`)
   - Принять дополнительные параметры (`country: str`, `germination_period: str`, `color: str`)
   - Вызвать `super().__init__(name, description, price, quantity)` для инициализации родительских атрибутов
   - Установить дополнительные атрибуты: `self.country = country`, `self.germination_period = germination_period`, `self.color = color`
4. Добавить docstring с описанием класса и атрибутов
5. Добавить примеры использования в docstring (см. `16.1_main.py` для примеров)

#### Шаг 1.3: Проверка наследования
1. Убедиться, что оба класса наследуют все методы от `Product`
2. Проверить, что можно использовать `__str__`, `__add__`, `price` property
3. Убедиться, что `isinstance(smartphone, Product)` возвращает `True`
4. Убедиться, что `isinstance(lawn_grass, Product)` возвращает `True`

#### Шаг 1.4: Обновление импортов
1. Проверить, что новые классы экспортируются в `__init__.py` (если нужно)
2. Обновить типизацию в других модулях (если используется)
3. **Важно:** В файле `16.1_main.py` нужно будет добавить импорты:
   ```python
   from src.product import Smartphone, LawnGrass
   from src.category import Category
   ```

**Ожидаемый результат:**
- Класс `Smartphone` создан и наследуется от `Product`
- Класс `LawnGrass` создан и наследуется от `Product`
- Все атрибуты родительского класса доступны
- Все методы родительского класса работают корректно
- Код в `16.1_main.py` работает после добавления импортов

---

## Задание 2: Доработка метода __add__

### 2.1. Анализ требований

**Задача:** Доработать метод `__add__` так, чтобы можно было складывать только товары из одинаковых классов продуктов.

**Текущее поведение:**
- Метод `__add__` проверяет только, что `other` является экземпляром `Product`
- Позволяет складывать любые продукты, включая `Smartphone` + `LawnGrass`

**Требуемое поведение:**
- Можно складывать: `Product` + `Product`, `Smartphone` + `Smartphone`, `LawnGrass` + `LawnGrass`
- Нельзя складывать: `Smartphone` + `LawnGrass`, `Product` + `Smartphone`, и т.д.
- При попытке сложить разные классы - выбрасывать `TypeError`

**Инструмент:** Использовать функцию `type()` для проверки точного типа объекта.

### 2.2. План реализации

#### Шаг 2.1: Анализ текущей реализации
1. Открыть `src/product.py`
2. Найти метод `__add__` в классе `Product`
3. Изучить текущую логику проверки типа

#### Шаг 2.2: Модификация метода __add__
1. Заменить проверку `isinstance(other, Product)` на проверку `type(self) == type(other)`
2. Обновить сообщение об ошибке:
   - Старое: `"Можно складывать только объекты класса Product"`
   - Новое: `"Можно складывать только товары из одинаковых классов продуктов"`
3. Обновить docstring метода с новым описанием поведения
4. Добавить примеры в docstring:
   - Пример успешного сложения одинаковых классов
   - Пример ошибки при сложении разных классов

#### Шаг 2.3: Проверка работы
1. Проверить, что `Product + Product` работает
2. Проверить, что `Smartphone + Smartphone` работает
3. Проверить, что `LawnGrass + LawnGrass` работает
4. Проверить, что `Smartphone + LawnGrass` выбрасывает `TypeError`
5. Проверить, что `Product + Smartphone` выбрасывает `TypeError`

**Ожидаемый результат:**
- Метод `__add__` проверяет точное совпадение типов через `type()`
- При попытке сложить разные классы выбрасывается `TypeError` с понятным сообщением
- Все существующие тесты на `__add__` для `Product + Product` продолжают работать

---

## Задание 3: Защита метода add_product

### 3.1. Анализ требований

**Задача:** Защитить метод `add_product` в классе `Category` так, чтобы можно было добавлять только объекты класса `Product` и его наследников.

**Текущее поведение:**
- Метод `add_product` принимает любой объект
- Нет проверки типа перед добавлением в список

**Требуемое поведение:**
- Можно добавлять: `Product`, `Smartphone`, `LawnGrass` и любые другие наследники `Product`
- Нельзя добавлять: строки, числа, списки, другие объекты
- При попытке добавить не-продукт - выбрасывать ошибку (или выводить сообщение)

**Инструменты:** 
- `isinstance()` - для проверки, является ли объект экземпляром класса или его наследника
- `issubclass()` - для проверки наследования (опционально, для более строгой проверки)

### 3.2. План реализации

#### Шаг 3.1: Анализ текущей реализации
1. Открыть `src/category.py`
2. Найти метод `add_product` в классе `Category`
3. Изучить текущую логику (нет проверки типа)

#### Шаг 3.2: Добавление проверки типа
1. В начале метода `add_product` добавить проверку:
   ```python
   if not isinstance(product, Product):
       raise TypeError("Можно добавлять только объекты класса Product и его наследников")
   ```
2. Альтернативный вариант (более строгий):
   ```python
   from src.product import Product
   if not isinstance(product, Product):
       raise TypeError("Можно добавлять только объекты класса Product и его наследников")
   ```
3. Обновить docstring метода:
   - Добавить информацию о проверке типа
   - Указать, что принимаются `Product` и его наследники
   - Добавить примеры использования с разными типами продуктов

#### Шаг 3.3: Проверка работы
1. Проверить, что можно добавить `Product`
2. Проверить, что можно добавить `Smartphone`
3. Проверить, что можно добавить `LawnGrass`
4. Проверить, что нельзя добавить строку (должна быть ошибка)
5. Проверить, что нельзя добавить число (должна быть ошибка)
6. Проверить, что нельзя добавить список (должна быть ошибка)

**Ожидаемый результат:**
- Метод `add_product` проверяет тип через `isinstance(product, Product)`
- При попытке добавить не-продукт выбрасывается `TypeError` с понятным сообщением
- Все существующие тесты на `add_product` продолжают работать
- Можно добавлять любые наследники `Product`

---

## Задание 4: Написание тестов

### 4.1. Анализ требований

**Задача:** Написать тесты для новой функциональности и убедиться, что все существующие тесты проходят.

**Области тестирования:**
1. Классы `Smartphone` и `LawnGrass` (инициализация, атрибуты, наследование)
2. Метод `__add__` с проверкой одинаковых типов
3. Метод `add_product` с защитой от не-продуктов
4. Интеграционные тесты (взаимодействие классов)

### 4.2. План реализации

#### Шаг 4.1: Тесты для класса Smartphone

**Файл:** `tests/test_product.py` (или создать `tests/test_smartphone.py`)

**Тесты для создания:**
1. `test_smartphone_init_with_all_attributes` - создание со всеми атрибутами
   - Пример: `Smartphone("Samsung Galaxy S23 Ultra", "256GB, Серый цвет, 200MP камера", 180000.0, 5, 95.5, "S23 Ultra", 256, "Серый")`
2. `test_smartphone_inherits_from_product` - проверка наследования
3. `test_smartphone_has_parent_attributes` - проверка доступа к родительским атрибутам
4. `test_smartphone_has_additional_attributes` - проверка дополнительных атрибутов
   - Проверить: `efficiency` (float), `model` (str), `memory` (int), `color` (str)

**Тесты для методов:**
5. `test_smartphone_str_representation` - проверка `__str__` (наследуется)
6. `test_smartphone_price_property` - проверка property `price` (наследуется)
7. `test_smartphone_add_with_same_type` - проверка `__add__` с другим `Smartphone`
8. `test_smartphone_add_with_different_type_raises_error` - проверка ошибки при сложении с `LawnGrass`

**Структура тестов:**
```python
class TestSmartphoneInit:
    """Тесты для инициализации класса Smartphone."""
    # Тесты создания

class TestSmartphoneInheritance:
    """Тесты для проверки наследования Smartphone от Product."""
    # Тесты наследования

class TestSmartphoneMethods:
    """Тесты для методов класса Smartphone."""
    # Тесты методов
```

#### Шаг 4.2: Тесты для класса LawnGrass

**Файл:** `tests/test_product.py` (или создать `tests/test_lawn_grass.py`)

**Тесты для создания:**
1. `test_lawn_grass_init_with_all_attributes` - создание со всеми атрибутами
   - Пример: `LawnGrass("Газонная трава", "Элитная трава для газона", 500.0, 20, "Россия", "7 дней", "Зеленый")`
2. `test_lawn_grass_inherits_from_product` - проверка наследования
3. `test_lawn_grass_has_parent_attributes` - проверка доступа к родительским атрибутам
4. `test_lawn_grass_has_additional_attributes` - проверка дополнительных атрибутов
   - Проверить: `country` (str), `germination_period` (str), `color` (str)

**Тесты для методов:**
5. `test_lawn_grass_str_representation` - проверка `__str__` (наследуется)
6. `test_lawn_grass_price_property` - проверка property `price` (наследуется)
7. `test_lawn_grass_add_with_same_type` - проверка `__add__` с другим `LawnGrass`
8. `test_lawn_grass_add_with_different_type_raises_error` - проверка ошибки при сложении с `Smartphone`

**Структура тестов:**
```python
class TestLawnGrassInit:
    """Тесты для инициализации класса LawnGrass."""
    # Тесты создания

class TestLawnGrassInheritance:
    """Тесты для проверки наследования LawnGrass от Product."""
    # Тесты наследования

class TestLawnGrassMethods:
    """Тесты для методов класса LawnGrass."""
    # Тесты методов
```

#### Шаг 4.3: Тесты для метода __add__ с проверкой типов

**Файл:** `tests/test_product.py` (расширить существующий класс `TestProductAdd`)

**Новые тесты:**
1. `test_add_product_with_product` - `Product + Product` работает
2. `test_add_smartphone_with_smartphone` - `Smartphone + Smartphone` работает
   - Пример из `16.1_main.py`: `smartphone1 + smartphone2` должно работать
3. `test_add_lawn_grass_with_lawn_grass` - `LawnGrass + LawnGrass` работает
   - Пример из `16.1_main.py`: `grass1 + grass2` должно работать
4. `test_add_smartphone_with_lawn_grass_raises_error` - `Smartphone + LawnGrass` выбрасывает `TypeError`
   - Пример из `16.1_main.py`: `smartphone1 + grass1` должно выбрасывать `TypeError`
5. `test_add_product_with_smartphone_raises_error` - `Product + Smartphone` выбрасывает `TypeError`
6. `test_add_product_with_lawn_grass_raises_error` - `Product + LawnGrass` выбрасывает `TypeError`
7. `test_add_smartphone_with_product_raises_error` - `Smartphone + Product` выбрасывает `TypeError`
8. `test_add_lawn_grass_with_product_raises_error` - `LawnGrass + Product` выбрасывает `TypeError`

**Важно:** Убедиться, что существующие тесты в `TestProductAdd` продолжают работать.

#### Шаг 4.4: Тесты для метода add_product с защитой

**Файл:** `tests/test_category.py` (расширить существующий класс `TestCategoryAddProduct`)

**Новые тесты:**
1. `test_add_product_accepts_product` - можно добавить `Product`
2. `test_add_product_accepts_smartphone` - можно добавить `Smartphone`
   - Пример из `16.1_main.py`: `category_smartphones.add_product(smartphone3)` должно работать
3. `test_add_product_accepts_lawn_grass` - можно добавить `LawnGrass`
4. `test_add_product_rejects_string` - нельзя добавить строку (TypeError)
   - Пример из `16.1_main.py`: `category_smartphones.add_product("Not a product")` должно выбрасывать `TypeError`
5. `test_add_product_rejects_int` - нельзя добавить число (TypeError)
6. `test_add_product_rejects_list` - нельзя добавить список (TypeError)
7. `test_add_product_rejects_dict` - нельзя добавить словарь (TypeError)
8. `test_add_product_rejects_none` - нельзя добавить `None` (TypeError)

**Важно:** Убедиться, что существующие тесты в `TestCategoryAddProduct` продолжают работать.

#### Шаг 4.5: Интеграционные тесты

**Файл:** `tests/test_product.py` или создать `tests/test_integration.py`

**Тесты:**
1. `test_smartphone_in_category` - создание категории со смартфонами
2. `test_lawn_grass_in_category` - создание категории с травой газонной
3. `test_mixed_products_in_category` - создание категории с разными типами продуктов
4. `test_category_iteration_with_inherited_products` - итерация по категории с наследниками

#### Шаг 4.6: Проверка существующих тестов

**Действия:**
1. Запустить все существующие тесты: `pytest tests/`
2. Убедиться, что все тесты проходят
3. Если тесты падают:
   - Проанализировать причину
   - Исправить код или тесты
   - Повторно запустить тесты

**Ожидаемый результат:**
- Все новые тесты написаны и проходят
- Все существующие тесты продолжают работать
- Покрытие кода не уменьшилось (желательно увеличилось)

---

## Детальный план выполнения (пошагово)

### Этап 1: Подготовка
1. ✅ Убедиться, что работаем в правильной ветке
2. ✅ Прочитать все требования еще раз
3. ✅ Понять структуру существующего кода

### Этап 2: Задание 1 - Создание классов-наследников

**2.1. Создание класса Smartphone**
- [x] Открыть `src/product.py`
- [x] Добавить класс `Smartphone(Product)` после класса `Product`
- [x] Реализовать `__init__` с вызовом `super().__init__()`
- [x] Добавить атрибуты: `efficiency`, `model`, `memory`, `color`
- [x] Написать docstring
- [x] Проверить работу вручную (создать объект)

**2.2. Создание класса LawnGrass**
- [x] Добавить класс `LawnGrass(Product)` после класса `Smartphone`
- [x] Реализовать `__init__` с вызовом `super().__init__()`
- [x] Добавить атрибуты: `country`, `germination_period`, `color`
- [x] Написать docstring
- [x] Проверить работу вручную (создать объект)

**2.3. Проверка наследования**
- [x] Проверить `isinstance(smartphone, Product)`
- [x] Проверить `isinstance(lawn_grass, Product)`
- [x] Проверить работу методов `__str__`, `price`

### Этап 3: Задание 2 - Доработка __add__

**3.1. Модификация метода**
- [x] Открыть метод `__add__` в классе `Product`
- [x] Заменить `isinstance(other, Product)` на `type(self) is not type(other)`
- [x] Обновить сообщение об ошибке
- [x] Обновить docstring

**3.2. Проверка работы**
- [x] Проверить `Product + Product` - работает
- [x] Проверить `Smartphone + Smartphone` - работает
- [x] Проверить `LawnGrass + LawnGrass` - работает
- [x] Проверить `Smartphone + LawnGrass` - ошибка
- [x] Проверить `Product + Smartphone` - ошибка

### Этап 4: Задание 3 - Защита add_product

**4.1. Добавление проверки**
- [x] Открыть метод `add_product` в классе `Category`
- [x] Добавить проверку `isinstance(product, Product)` в начале метода
- [x] Добавить `raise TypeError` с понятным сообщением
- [x] Обновить docstring
- [x] Добавить проверку дубликатов через `__eq__`
- [x] Добавить проверку типов в `Category.__init__`

**4.2. Проверка работы**
- [x] Проверить добавление `Product` - работает
- [x] Проверить добавление `Smartphone` - работает
- [x] Проверить добавление `LawnGrass` - работает
- [x] Проверить добавление строки - ошибка
- [x] Проверить добавление числа - ошибка
- [x] Проверить добавление дубликата - ошибка

### Этап 5: Задание 4 - Написание тестов

**5.1. Тесты для Smartphone**
- [x] Создать класс `TestSmartphoneInit`
- [x] Написать тесты инициализации (4 теста)
- [x] Создать класс `TestSmartphoneInheritance`
- [x] Написать тесты наследования (2-3 теста)
- [x] Создать класс `TestSmartphoneMethods`
- [x] Написать тесты методов (3-4 теста)
- [x] Запустить тесты, убедиться что проходят

**5.2. Тесты для LawnGrass**
- [x] Создать класс `TestLawnGrassInit`
- [x] Написать тесты инициализации (4 теста)
- [x] Создать класс `TestLawnGrassInheritance`
- [x] Написать тесты наследования (2-3 теста)
- [x] Создать класс `TestLawnGrassMethods`
- [x] Написать тесты методов (3-4 теста)
- [x] Запустить тесты, убедиться что проходят

**5.3. Тесты для __add__**
- [x] Расширить класс `TestProductAdd`
- [x] Написать тесты для одинаковых типов (3 теста)
- [x] Написать тесты для разных типов (5 тестов)
- [x] Запустить тесты, убедиться что проходят
- [x] Убедиться, что старые тесты продолжают работать

**5.4. Тесты для add_product**
- [x] Расширить класс `TestCategoryAddProduct`
- [x] Написать тесты для принятия продуктов (3 теста)
- [x] Написать тесты для отклонения не-продуктов (5 тестов)
- [x] Написать тесты для проверки дубликатов (6 тестов)
- [x] Запустить тесты, убедиться что проходят
- [x] Убедиться, что старые тесты продолжают работать

**5.5. Интеграционные тесты**
- [x] Написать тесты взаимодействия классов (3-4 теста)
- [x] Написать тесты для `__eq__` с разными типами (3 теста)
- [x] Написать тесты для валидации отрицательных значений (2 теста)
- [x] Запустить тесты, убедиться что проходят

**5.6. Финальная проверка**
- [x] Запустить все тесты: `pytest tests/ -v`
- [x] Убедиться, что все тесты проходят (151 тест)
- [x] Проверить покрытие кода: `pytest --cov=src tests/`
- [x] Убедиться, что покрытие не уменьшилось (98%)

### Этап 6: Финальная проверка и форматирование

**6.1. Форматирование кода**
- [x] Запустить `black .` для форматирования
- [x] Запустить `isort .` для сортировки импортов
- [x] Проверить линтер: `flake8 .`

**6.2. Проверка типизации**
- [x] Проверить типизацию: `mypy .` (если используется)
- [x] Убедиться, что нет ошибок типизации

**6.3. Проверка на баги**
- [x] Запустить статический анализатор кода (pylint, bandit или аналогичный)
- [x] Проверить код на логические ошибки:
  - [x] Корректность работы наследования
  - [x] Правильность проверок типов в `__add__` и `add_product`
  - [x] Отсутствие утечек памяти или проблем с циклическими ссылками
  - [x] Корректность обработки граничных случаев
- [x] Проверить код на потенциальные ошибки времени выполнения
- [x] Убедиться, что все исключения обрабатываются корректно
- [x] Исправлено: удален недостижимый код в price setter
- [x] Исправлено: добавлена защита от обхода валидации через приватный атрибут

**6.4. Финальная проверка**
- [x] Запустить все тесты еще раз
- [x] Проверить, что нет ошибок линтера
- [x] Убедиться, что код соответствует стандартам проекта
- [x] Добавлена валидация отрицательных значений
- [x] Добавлена проверка дубликатов
- [x] Добавлен метод `__eq__` для всех классов

---

## Критерии проверки выполнения

### Задание 1: Классы-наследники
- [x] Класс `Smartphone` создан и наследуется от `Product`
- [x] Класс `Smartphone` имеет все требуемые атрибуты: `efficiency`, `model`, `memory`, `color`
- [x] Класс `LawnGrass` создан и наследуется от `Product`
- [x] Класс `LawnGrass` имеет все требуемые атрибуты: `country`, `germination_period`, `color`
- [x] Оба класса корректно используют `super().__init__()`
- [x] Все методы родительского класса доступны и работают
- [x] `isinstance(smartphone, Product)` возвращает `True`
- [x] `isinstance(lawn_grass, Product)` возвращает `True`
- [x] Добавлен метод `__eq__` для сравнения продуктов

### Задание 2: Метод __add__
- [x] Метод `__add__` использует `type()` для проверки типов
- [x] `Product + Product` работает корректно
- [x] `Smartphone + Smartphone` работает корректно
- [x] `LawnGrass + LawnGrass` работает корректно
- [x] `Smartphone + LawnGrass` выбрасывает `TypeError`
- [x] `Product + Smartphone` выбрасывает `TypeError`
- [x] Сообщение об ошибке понятное и информативное

### Задание 3: Метод add_product
- [x] Метод `add_product` использует `isinstance()` для проверки типа
- [x] Можно добавить `Product` в категорию
- [x] Можно добавить `Smartphone` в категорию
- [x] Можно добавить `LawnGrass` в категорию
- [x] Нельзя добавить строку (TypeError)
- [x] Нельзя добавить число (TypeError)
- [x] Нельзя добавить список (TypeError)
- [x] Нельзя добавить дубликат (ValueError)
- [x] Сообщение об ошибке понятное и информативное
- [x] Добавлена проверка типов в `Category.__init__`

### Задание 4: Тесты
- [x] Написаны тесты для `Smartphone` (10+ тестов)
- [x] Написаны тесты для `LawnGrass` (10+ тестов)
- [x] Написаны тесты для `__add__` с проверкой типов (8+ тестов)
- [x] Написаны тесты для `add_product` с защитой (17 тестов)
- [x] Написаны тесты для валидации отрицательных значений (4 теста)
- [x] Написаны тесты для проверки дубликатов (6 тестов)
- [x] Все новые тесты проходят (151 тест)
- [x] Все существующие тесты продолжают работать
- [x] Покрытие кода увеличилось (98%)

---

## Полезные ссылки и подсказки

### Наследование в Python
- Использование `super()` для вызова методов родителя
- Переопределение методов в наследниках
- Доступ к приватным атрибутам родителя

### Проверка типов
- `type(obj)` - возвращает точный тип объекта
- `isinstance(obj, Class)` - проверяет, является ли объект экземпляром класса или его наследника
- `issubclass(Class1, Class2)` - проверяет, является ли Class1 наследником Class2

### Тестирование
- Использование `pytest.raises()` для проверки исключений
- Фикстуры для создания тестовых объектов
- Параметризация тестов для проверки нескольких случаев

### Проверка на баги
- Статические анализаторы: `pylint`, `bandit`, `prospector`
- Проверка логики кода: ручной просмотр на предмет ошибок в наследовании, проверках типов
- Проверка граничных случаев: пустые значения, None, отрицательные числа
- Проверка обработки исключений: корректность выброса и обработки TypeError

---

## Важные замечания

1. **Обратная совместимость:** Все существующие тесты должны продолжать работать после изменений.

2. **Типизация:** При необходимости обновить type hints для новых классов.

3. **Документация:** Обновить docstrings для всех измененных методов.

4. **Стандарты кода:** Следовать существующим стандартам проекта (black, isort, flake8).

5. **Проверка на баги:** Обязательно выполнить проверку кода на баги с помощью статических анализаторов (pylint, bandit) и ручной проверки логики кода.

6. **Логирование:** При необходимости добавить логирование для новых проверок.

---

## Чеклист перед завершением

- [x] Все задания выполнены
- [x] Все тесты написаны и проходят (151 тест)
- [x] Существующие тесты продолжают работать
- [x] Код отформатирован (black, isort)
- [x] Линтер не выдает ошибок (flake8)
- [x] Типизатор не выдает ошибок (mypy)
- [x] Проверка на баги выполнена (статический анализ, проверка логики)
- [x] Документация обновлена (README, docstrings)
- [x] **Код в `16.1_main.py` выполняется без ошибок** (после добавления импортов)
- [ ] Код закоммичен в ветку
- [x] Покрытие кода проверено (98%)

## Чеклист по критериям оценки задания

### Общие критерии
- [x] Реализованный код соответствует PEP 8
- [x] В README-файл добавлено как минимум упоминание о реализованной в этом задании функциональности проекта
- [x] Весь имеющийся код в файле `main.py` (или `16.1_main.py`) запускается без ошибок

### Классы-наследники
- [x] Созданы два класса наследников класса `Product`: «Смартфон» (`Smartphone`) и «Трава газонная` (`LawnGrass`)
- [x] Класс «Смартфон» (`Smartphone`) расширен атрибутами: производительность (`efficiency`), модель (`model`), объем встроенной памяти (`memory`), цвет (`color`)
- [x] Класс «Трава газонная» (`LawnGrass`) расширен атрибутами: страна-производитель (`country`), срок прорастания (`germination_period`), цвет (`color`)

### Ограничения сложения
- [x] Доработана функциональность сложения таким образом, чтобы можно было складывать товары только из одинаковых классов продуктов
- [x] Новая функциональность не дает возможности сложить объекты разных классов, например смартфон и траву газонную. При попытке сложения таких экземпляров выбрасывается ошибка `TypeError`
- [x] Для реализации ограничений используется функция `type()`

### Ограничения добавления продукта
- [x] Доработан метод, который добавляет продукт в категорию таким образом, чтобы не было возможности добавить вместо продукта или его наследников любой другой объект
- [x] Для реализации ограничений используются функции `issubclass()` или `isinstance()`
- [x] Добавлена защита от дубликатов через метод `__eq__`

### Тестирование
- [x] Написаны тесты для новой функциональности (151 тест)
- [x] В репозитории есть отчет о покрытии тестами (htmlcov/)
- [x] Покрытие функционального кода тестами — более 95% (98%)

### Дополнительные улучшения
- [x] Добавлена валидация отрицательных значений цены и количества
- [x] Добавлен метод `__eq__` для сравнения продуктов
- [x] Добавлена защита от обхода валидации через приватный атрибут
- [x] Исправлены обнаруженные баги

## Проверка работы с 16.1_main.py

После выполнения всех заданий необходимо убедиться, что код в `16.1_main.py` работает:

1. **Добавить импорты в начало файла `16.1_main.py`:**
   ```python
   from src.product import Smartphone, LawnGrass
   from src.category import Category
   ```

2. **Запустить файл:**
   ```bash
   python 16.1_main.py
   ```

3. **Ожидаемое поведение:**
   - Создание объектов `Smartphone` и `LawnGrass` работает
   - Вывод всех атрибутов работает
   - Сложение `smartphone1 + smartphone2` работает и выводит число
   - Сложение `grass1 + grass2` работает и выводит число
   - Попытка сложить `smartphone1 + grass1` выбрасывает `TypeError` и выводит сообщение
   - Создание категорий с продуктами работает
   - Добавление продукта в категорию работает
   - Попытка добавить строку в категорию выбрасывает `TypeError` и выводит сообщение
   - Вывод `Category.product_count` работает

---

**Дата создания плана:** [текущая дата]  
**Дата завершения:** [текущая дата]  
**Статус:** ✅ Выполнено  
**Приоритет:** Высокий

## Итоговая статистика выполнения

- **Всего заданий:** 4
- **Выполнено заданий:** 4 (100%)
- **Всего тестов:** 151
- **Пройдено тестов:** 151 (100%)
- **Покрытие кода:** 98%
- **Исправлено багов:** 2
- **Добавлено функционала:**
  - Классы-наследники: Smartphone, LawnGrass
  - Валидация отрицательных значений
  - Защита от дубликатов
  - Метод __eq__ для всех классов
  - Защита от обхода валидации

